<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/id/stargan/intikasir/feature/auth/ui/login/LoginViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/id/stargan/intikasir/feature/auth/ui/login/LoginViewModel.kt" />
              <option name="originalContent" value="package id.stargan.intikasir.feature.auth.ui.login&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import id.stargan.intikasir.feature.auth.domain.model.AuthErrorType&#10;import id.stargan.intikasir.feature.auth.domain.model.AuthResult&#10;import id.stargan.intikasir.feature.auth.domain.usecase.LoginUseCase&#10;import id.stargan.intikasir.feature.auth.domain.usecase.ValidatePinUseCase&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;/**&#10; * ViewModel untuk Login Screen&#10; * Menggunakan MVI pattern dengan single state flow&#10; */&#10;@HiltViewModel&#10;class LoginViewModel @Inject constructor(&#10;    private val loginUseCase: LoginUseCase,&#10;    private val validatePinUseCase: ValidatePinUseCase&#10;) : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow(LoginUiState())&#10;    val uiState: StateFlow&lt;LoginUiState&gt; = _uiState.asStateFlow()&#10;&#10;    /**&#10;     * Handle UI events&#10;     */&#10;    fun onEvent(event: LoginUiEvent) {&#10;        when (event) {&#10;            is LoginUiEvent.PinChanged -&gt; {&#10;                handlePinChanged(event.pin)&#10;            }&#10;            is LoginUiEvent.LoginClicked -&gt; {&#10;                handleLogin()&#10;            }&#10;            is LoginUiEvent.ClearPin -&gt; {&#10;                clearPin()&#10;            }&#10;            is LoginUiEvent.DismissError -&gt; {&#10;                dismissError()&#10;            }&#10;            is LoginUiEvent.NavigatedToHome -&gt; {&#10;                // Reset state after navigation&#10;                _uiState.update { it.copy(isSuccess = false) }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle PIN input change&#10;     */&#10;    private fun handlePinChanged(pin: String) {&#10;        // Only allow numeric input and max 6 digits&#10;        val filteredPin = pin.filter { it.isDigit() }.take(6)&#10;&#10;        _uiState.update { currentState -&gt;&#10;            currentState.copy(&#10;                pin = filteredPin,&#10;                showPinError = false,&#10;                pinErrorMessage = null,&#10;                error = null&#10;            )&#10;        }&#10;&#10;        // Validate PIN format real-time&#10;        if (filteredPin.isNotEmpty()) {&#10;            val validation = validatePinUseCase(filteredPin)&#10;            if (validation.isFailure) {&#10;                _uiState.update { currentState -&gt;&#10;                    currentState.copy(&#10;                        showPinError = true,&#10;                        pinErrorMessage = validation.exceptionOrNull()?.message&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle login action&#10;     */&#10;    private fun handleLogin() {&#10;        val currentPin = _uiState.value.pin&#10;&#10;        // Validate PIN before login&#10;        val validation = validatePinUseCase(currentPin)&#10;        if (validation.isFailure) {&#10;            _uiState.update { currentState -&gt;&#10;                currentState.copy(&#10;                    showPinError = true,&#10;                    pinErrorMessage = validation.exceptionOrNull()?.message&#10;                )&#10;            }&#10;            return&#10;        }&#10;&#10;        // Proceed with login&#10;        viewModelScope.launch {&#10;            loginUseCase(currentPin).collect { result -&gt;&#10;                when (result) {&#10;                    is AuthResult.Loading -&gt; {&#10;                        _uiState.update { currentState -&gt;&#10;                            currentState.copy(&#10;                                isLoading = true,&#10;                                error = null,&#10;                                errorType = null&#10;                            )&#10;                        }&#10;                    }&#10;                    is AuthResult.Success -&gt; {&#10;                        _uiState.update { currentState -&gt;&#10;                            currentState.copy(&#10;                                isLoading = false,&#10;                                isSuccess = true,&#10;                                loggedInUser = result.user,&#10;                                error = null,&#10;                                errorType = null,&#10;                                pin = &quot;&quot; // Clear PIN after success&#10;                            )&#10;                        }&#10;                    }&#10;                    is AuthResult.Error -&gt; {&#10;                        _uiState.update { currentState -&gt;&#10;                            currentState.copy(&#10;                                isLoading = false,&#10;                                error = result.message,&#10;                                errorType = mapAuthErrorToUiError(result.errorType),&#10;                                isSuccess = false&#10;                            )&#10;                        }&#10;                    }&#10;                    is AuthResult.Idle -&gt; {&#10;                        // Do nothing&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Clear PIN input&#10;     */&#10;    private fun clearPin() {&#10;        _uiState.update { currentState -&gt;&#10;            currentState.copy(&#10;                pin = &quot;&quot;,&#10;                showPinError = false,&#10;                pinErrorMessage = null&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Dismiss error message&#10;     */&#10;    private fun dismissError() {&#10;        _uiState.update { currentState -&gt;&#10;            currentState.copy(&#10;                error = null,&#10;                errorType = null&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Map domain error type to UI error type&#10;     */&#10;    private fun mapAuthErrorToUiError(errorType: AuthErrorType): LoginErrorType {&#10;        return when (errorType) {&#10;            AuthErrorType.INVALID_PIN -&gt; LoginErrorType.INVALID_PIN&#10;            AuthErrorType.USER_NOT_FOUND -&gt; LoginErrorType.USER_NOT_FOUND&#10;            AuthErrorType.USER_INACTIVE -&gt; LoginErrorType.USER_INACTIVE&#10;            AuthErrorType.NETWORK_ERROR -&gt; LoginErrorType.NETWORK_ERROR&#10;            else -&gt; LoginErrorType.UNKNOWN&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package id.stargan.intikasir.feature.auth.ui.login&#13;&#10;&#13;&#10;import androidx.lifecycle.ViewModel&#13;&#10;import androidx.lifecycle.viewModelScope&#13;&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#13;&#10;import id.stargan.intikasir.feature.auth.domain.model.AuthErrorType&#13;&#10;import id.stargan.intikasir.feature.auth.domain.model.AuthResult&#13;&#10;import id.stargan.intikasir.feature.auth.domain.usecase.LoginUseCase&#13;&#10;import id.stargan.intikasir.feature.auth.domain.usecase.ValidatePinUseCase&#13;&#10;import kotlinx.coroutines.flow.MutableStateFlow&#13;&#10;import kotlinx.coroutines.flow.StateFlow&#13;&#10;import kotlinx.coroutines.flow.asStateFlow&#13;&#10;import kotlinx.coroutines.flow.update&#13;&#10;import kotlinx.coroutines.launch&#13;&#10;import javax.inject.Inject&#13;&#10;&#13;&#10;/**&#13;&#10; * ViewModel untuk Login Screen&#13;&#10; * Menggunakan MVI pattern dengan single state flow&#13;&#10; */&#13;&#10;@HiltViewModel&#13;&#10;class LoginViewModel @Inject constructor(&#13;&#10;    private val loginUseCase: LoginUseCase,&#13;&#10;    private val validatePinUseCase: ValidatePinUseCase&#13;&#10;) : ViewModel() {&#13;&#10;&#13;&#10;    private val _uiState = MutableStateFlow(LoginUiState())&#13;&#10;    val uiState: StateFlow&lt;LoginUiState&gt; = _uiState.asStateFlow()&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Handle UI events&#13;&#10;     */&#13;&#10;    fun onEvent(event: LoginUiEvent) {&#13;&#10;        when (event) {&#13;&#10;            is LoginUiEvent.PinChanged -&gt; {&#13;&#10;                handlePinChanged(event.pin)&#13;&#10;            }&#13;&#10;            is LoginUiEvent.LoginClicked -&gt; {&#13;&#10;                handleLogin()&#13;&#10;            }&#13;&#10;            is LoginUiEvent.ClearPin -&gt; {&#13;&#10;                clearPin()&#13;&#10;            }&#13;&#10;            is LoginUiEvent.DismissError -&gt; {&#13;&#10;                dismissError()&#13;&#10;            }&#13;&#10;            is LoginUiEvent.NavigatedToHome -&gt; {&#13;&#10;                // Reset state after navigation&#13;&#10;                _uiState.update { it.copy(isSuccess = false) }&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#10;     * Handle PIN input change&#10;     */&#10;    private fun handlePinChanged(pin: String) {&#10;        // Only allow numeric input and max 6 digits&#10;        val filteredPin = pin.filter { it.isDigit() }.take(6)&#10;&#10;        _uiState.update { currentState -&gt;&#10;            currentState.copy(&#10;                pin = filteredPin,&#10;                showPinError = false,&#10;                pinErrorMessage = null,&#10;                error = null&#10;            )&#10;        }&#10;&#10;        // Note: Tidak perlu validasi real-time saat user mengetik&#10;        // Validasi hanya dilakukan saat user klik tombol Login&#10;        // Ini memberikan UX yang lebih baik karena user tidak diganggu&#10;        // dengan error message saat masih mengetik PIN&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Handle login action&#13;&#10;     */&#13;&#10;    private fun handleLogin() {&#13;&#10;        val currentPin = _uiState.value.pin&#13;&#10;&#13;&#10;        // Validate PIN before login&#13;&#10;        val validation = validatePinUseCase(currentPin)&#13;&#10;        if (validation.isFailure) {&#13;&#10;            _uiState.update { currentState -&gt;&#13;&#10;                currentState.copy(&#13;&#10;                    showPinError = true,&#13;&#10;                    pinErrorMessage = validation.exceptionOrNull()?.message&#13;&#10;                )&#13;&#10;            }&#13;&#10;            return&#13;&#10;        }&#13;&#10;&#13;&#10;        // Proceed with login&#13;&#10;        viewModelScope.launch {&#13;&#10;            loginUseCase(currentPin).collect { result -&gt;&#13;&#10;                when (result) {&#13;&#10;                    is AuthResult.Loading -&gt; {&#13;&#10;                        _uiState.update { currentState -&gt;&#13;&#10;                            currentState.copy(&#13;&#10;                                isLoading = true,&#13;&#10;                                error = null,&#13;&#10;                                errorType = null&#13;&#10;                            )&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;                    is AuthResult.Success -&gt; {&#13;&#10;                        _uiState.update { currentState -&gt;&#13;&#10;                            currentState.copy(&#13;&#10;                                isLoading = false,&#13;&#10;                                isSuccess = true,&#13;&#10;                                loggedInUser = result.user,&#13;&#10;                                error = null,&#13;&#10;                                errorType = null,&#13;&#10;                                pin = &quot;&quot; // Clear PIN after success&#13;&#10;                            )&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;                    is AuthResult.Error -&gt; {&#13;&#10;                        _uiState.update { currentState -&gt;&#13;&#10;                            currentState.copy(&#13;&#10;                                isLoading = false,&#13;&#10;                                error = result.message,&#13;&#10;                                errorType = mapAuthErrorToUiError(result.errorType),&#13;&#10;                                isSuccess = false&#13;&#10;                            )&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;                    is AuthResult.Idle -&gt; {&#13;&#10;                        // Do nothing&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Clear PIN input&#13;&#10;     */&#13;&#10;    private fun clearPin() {&#13;&#10;        _uiState.update { currentState -&gt;&#13;&#10;            currentState.copy(&#13;&#10;                pin = &quot;&quot;,&#13;&#10;                showPinError = false,&#13;&#10;                pinErrorMessage = null&#13;&#10;            )&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Dismiss error message&#13;&#10;     */&#13;&#10;    private fun dismissError() {&#13;&#10;        _uiState.update { currentState -&gt;&#13;&#10;            currentState.copy(&#13;&#10;                error = null,&#13;&#10;                errorType = null&#13;&#10;            )&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Map domain error type to UI error type&#13;&#10;     */&#13;&#10;    private fun mapAuthErrorToUiError(errorType: AuthErrorType): LoginErrorType {&#13;&#10;        return when (errorType) {&#13;&#10;            AuthErrorType.INVALID_PIN -&gt; LoginErrorType.INVALID_PIN&#13;&#10;            AuthErrorType.USER_NOT_FOUND -&gt; LoginErrorType.USER_NOT_FOUND&#13;&#10;            AuthErrorType.USER_INACTIVE -&gt; LoginErrorType.USER_INACTIVE&#13;&#10;            AuthErrorType.NETWORK_ERROR -&gt; LoginErrorType.NETWORK_ERROR&#13;&#10;            else -&gt; LoginErrorType.UNKNOWN&#13;&#10;        }&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>