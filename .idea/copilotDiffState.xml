<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/id/stargan/intikasir/feature/pos/print/ThermalLogoPrinter.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/id/stargan/intikasir/feature/pos/print/ThermalLogoPrinter.kt" />
              <option name="originalContent" value="package id.stargan.intikasir.feature.pos.print&#10;&#10;import android.content.Context&#10;import android.graphics.Bitmap&#10;import android.graphics.BitmapFactory&#10;import android.util.Log&#10;import androidx.core.graphics.scale&#10;import id.stargan.intikasir.domain.model.StoreSettings&#10;import java.io.File&#10;import java.io.OutputStream&#10;import kotlin.math.min&#10;&#10;/**&#10; * Helper untuk mencetak logo pada thermal printer&#10; * Mengatur ukuran logo: jika lebar kertas = 3a, maka logo = a x a (square, 1/3 dari lebar kertas)&#10; */&#10;object ThermalLogoPrinter {&#10;    private const val TAG = &quot;ThermalLogoPrinter&quot;&#10;&#10;    /**&#10;     * Print logo to thermal printer via ESC/POS commands&#10;     * Logo size calculation: if paper width = 3a, then logo = a x a&#10;     *&#10;     * @param context Android context&#10;     * @param out OutputStream to thermal printer&#10;     * @param settings Store settings containing logo path and paper width&#10;     * @return true if logo printed successfully, false otherwise&#10;     */&#10;    fun printLogo(&#10;        context: Context,&#10;        out: OutputStream,&#10;        settings: StoreSettings&#10;    ): Boolean {&#10;        if (!settings.printLogo || settings.storeLogo.isNullOrBlank()) {&#10;            Log.d(TAG, &quot;Logo printing disabled or logo path empty&quot;)&#10;            return false&#10;        }&#10;&#10;        try {&#10;            val logoFile = File(settings.storeLogo)&#10;            if (!logoFile.exists()) {&#10;                Log.w(TAG, &quot;Logo file does not exist: ${settings.storeLogo}&quot;)&#10;                return false&#10;            }&#10;&#10;            val originalBitmap = BitmapFactory.decodeFile(settings.storeLogo)&#10;            if (originalBitmap == null) {&#10;                Log.w(TAG, &quot;Failed to decode logo bitmap&quot;)&#10;                return false&#10;            }&#10;&#10;            Log.d(TAG, &quot;Original bitmap size: ${originalBitmap.width}x${originalBitmap.height}&quot;)&#10;&#10;            // Calculate logo size based on paper width&#10;            // Paper width in mm, convert to dots (thermal printers typically 8 dots per mm)&#10;            val paperWidthMm = settings.paperWidthMm&#10;            val dotsPerMm = 8 // Standard thermal printer resolution&#10;            val paperWidthDots = paperWidthMm * dotsPerMm&#10;&#10;            // Logo should be proportional to paper width&#10;            // For receipt, logo should be small and neat: ~1/4 to 1/5 of paper width&#10;            val targetLogoSize = when {&#10;                paperWidthMm &gt;= 80 -&gt; 96  // ~12mm for 80mm paper (1/5 of width)&#10;                else -&gt; 64 // ~8mm for 58mm paper (1/5 of width)&#10;            }&#10;&#10;            Log.d(TAG, &quot;Paper width: ${paperWidthMm}mm = ${paperWidthDots} dots&quot;)&#10;            Log.d(TAG, &quot;Target logo size: ${targetLogoSize}x${targetLogoSize} dots&quot;)&#10;&#10;            // Create square bitmap from original&#10;            // Find the smaller dimension and crop from center to get square&#10;            val cropSize = min(originalBitmap.width, originalBitmap.height)&#10;            val xOffset = (originalBitmap.width - cropSize) / 2&#10;            val yOffset = (originalBitmap.height - cropSize) / 2&#10;&#10;            val squareBitmap = Bitmap.createBitmap(&#10;                originalBitmap,&#10;                xOffset,&#10;                yOffset,&#10;                cropSize,&#10;                cropSize&#10;            )&#10;&#10;            Log.d(TAG, &quot;Cropped to square: ${squareBitmap.width}x${squareBitmap.height}&quot;)&#10;&#10;            // Verify it's actually square&#10;            if (squareBitmap.width != squareBitmap.height) {&#10;                Log.e(TAG, &quot;ERROR: Bitmap is not square after cropping!&quot;)&#10;            }&#10;&#10;            // Now scale the square bitmap to target size&#10;            val scaledBitmap = squareBitmap.scale(&#10;                targetLogoSize,&#10;                targetLogoSize,&#10;                filter = true&#10;            )&#10;&#10;            Log.d(TAG, &quot;Scaled bitmap size: ${scaledBitmap.width}x${scaledBitmap.height}&quot;)&#10;&#10;            // Verify scaled is also square&#10;            if (scaledBitmap.width != scaledBitmap.height) {&#10;                Log.e(TAG, &quot;ERROR: Scaled bitmap is not square!&quot;)&#10;            }&#10;&#10;            // Print the bitmap centered&#10;            printBitmapCentered(out, scaledBitmap, paperWidthDots)&#10;&#10;            // Cleanup&#10;            squareBitmap.recycle()&#10;&#10;            // Cleanup&#10;            scaledBitmap.recycle()&#10;            originalBitmap.recycle()&#10;&#10;            Log.d(TAG, &quot;Logo printed successfully&quot;)&#10;            return true&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error printing logo&quot;, e)&#10;            return false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Print bitmap image centered using ESC/POS commands&#10;     * Uses 24-dot double-density mode for correct 1:1 aspect ratio&#10;     */&#10;    private fun printBitmapCentered(&#10;        out: OutputStream,&#10;        bitmap: Bitmap,&#10;        paperWidthDots: Int&#10;    ) {&#10;        // Convert to monochrome&#10;        val threshold = 128&#10;        val dots = Array(bitmap.height) { y -&gt;&#10;            BooleanArray(bitmap.width) { x -&gt;&#10;                val pixel = bitmap.getPixel(x, y)&#10;                val r = (pixel shr 16) and 0xFF&#10;                val g = (pixel shr 8) and 0xFF&#10;                val b = pixel and 0xFF&#10;                val gray = (r + g + b) / 3&#10;                gray &lt; threshold // dark pixels become true&#10;            }&#10;        }&#10;&#10;        Log.d(TAG, &quot;Converted to monochrome: ${dots.size} rows x ${dots[0].size} cols&quot;)&#10;&#10;        // Calculate left margin for centering (in dots, then convert to mm for left margin command)&#10;        val leftMarginDots = ((paperWidthDots - bitmap.width) / 2).coerceAtLeast(0)&#10;        val leftMarginMm = (leftMarginDots / 8).coerceAtLeast(0) // 8 dots per mm&#10;&#10;        Log.d(TAG, &quot;Paper width: $paperWidthDots dots&quot;)&#10;        Log.d(TAG, &quot;Bitmap width: ${bitmap.width} dots&quot;)&#10;        Log.d(TAG, &quot;Left margin: $leftMarginDots dots (~${leftMarginMm}mm)&quot;)&#10;&#10;        // Set left margin for centering&#10;        if (leftMarginMm &gt; 0) {&#10;            // GS L nL nH - Set left margin&#10;            val nL = (leftMarginMm and 0xFF).toByte()&#10;            val nH = ((leftMarginMm shr 8) and 0xFF).toByte()&#10;            out.write(byteArrayOf(0x1D, 0x4C, nL, nH))&#10;        }&#10;&#10;        // Print using ESC * command in 24-dot double-density mode for correct aspect ratio&#10;        // Process in strips of 24 dots height (3 bytes per column)&#10;        var y = 0&#10;        while (y &lt; dots.size) {&#10;            val stripHeight = min(24, dots.size - y)&#10;&#10;            // ESC * m nL nH d1...dk&#10;            // m = 33 (24-dot double-density, 200x200 DPI) - gives 1:1 aspect ratio&#10;            val nL = (bitmap.width and 0xFF).toByte()&#10;            val nH = ((bitmap.width shr 8) and 0xFF).toByte()&#10;&#10;            out.write(byteArrayOf(0x1B, 0x2A, 33, nL, nH))&#10;&#10;            // Send bitmap data column by column&#10;            for (x in 0 until bitmap.width) {&#10;                // Each column is 3 bytes for 24 dots&#10;                val bytes = ByteArray(3)&#10;                for (k in 0 until stripHeight) {&#10;                    val dotY = y + k&#10;                    if (dotY &lt; dots.size &amp;&amp; x &lt; dots[dotY].size &amp;&amp; dots[dotY][x]) {&#10;                        val byteIndex = k / 8&#10;                        val bitIndex = 7 - (k % 8)&#10;                        bytes[byteIndex] = (bytes[byteIndex].toInt() or (1 shl bitIndex)).toByte()&#10;                    }&#10;                }&#10;                out.write(bytes)&#10;            }&#10;&#10;            // Line feed - move to next strip&#10;            out.write(byteArrayOf(0x0A))&#10;            y += 24&#10;        }&#10;&#10;        // Reset left margin to 0&#10;        out.write(byteArrayOf(0x1D, 0x4C, 0x00, 0x00))&#10;&#10;        // NO extra line feed - let ESCPosPrinter handle spacing&#10;&#10;        // Flush output to ensure all data is sent&#10;        out.flush()&#10;&#10;        // Small delay to let printer process the bitmap&#10;        try {&#10;            Thread.sleep(50)&#10;        } catch (e: InterruptedException) {&#10;            Log.w(TAG, &quot;Sleep interrupted&quot;, e)&#10;        }&#10;&#10;        Log.d(TAG, &quot;Bitmap printed, total strips: ${(bitmap.height + 23) / 24}&quot;)&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package id.stargan.intikasir.feature.pos.print&#10;&#10;import android.content.Context&#10;import android.graphics.Bitmap&#10;import android.graphics.BitmapFactory&#10;import android.util.Log&#10;import androidx.core.graphics.get&#10;import androidx.core.graphics.scale&#10;import id.stargan.intikasir.domain.model.StoreSettings&#10;import java.io.File&#10;import java.io.OutputStream&#10;import kotlin.math.min&#10;&#10;/**&#10; * Helper untuk mencetak logo pada thermal printer&#10; * Mengatur ukuran logo: jika lebar kertas = 3a, maka logo = a x a (square, 1/3 dari lebar kertas)&#10; */&#10;object ThermalLogoPrinter {&#10;    private const val TAG = &quot;ThermalLogoPrinter&quot;&#10;&#10;    /**&#10;     * Print logo to thermal printer via ESC/POS commands&#10;     * Logo size calculation: if paper width = 3a, then logo = a x a&#10;     *&#10;     * @param context Android context&#10;     * @param out OutputStream to thermal printer&#10;     * @param settings Store settings containing logo path and paper width&#10;     * @return true if logo printed successfully, false otherwise&#10;     */&#10;    fun printLogo(&#10;        context: Context,&#10;        out: OutputStream,&#10;        settings: StoreSettings&#10;    ): Boolean {&#10;        if (!settings.printLogo || settings.storeLogo.isNullOrBlank()) {&#10;            Log.d(TAG, &quot;Logo printing disabled or logo path empty&quot;)&#10;            return false&#10;        }&#10;&#10;        try {&#10;            val logoFile = File(settings.storeLogo)&#10;            if (!logoFile.exists()) {&#10;                Log.w(TAG, &quot;Logo file does not exist: ${settings.storeLogo}&quot;)&#10;                return false&#10;            }&#10;&#10;            val originalBitmap = BitmapFactory.decodeFile(settings.storeLogo)&#10;            if (originalBitmap == null) {&#10;                Log.w(TAG, &quot;Failed to decode logo bitmap&quot;)&#10;                return false&#10;            }&#10;&#10;            Log.d(TAG, &quot;Original bitmap size: ${originalBitmap.width}x${originalBitmap.height}&quot;)&#10;&#10;            // Calculate logo size based on paper width&#10;            // Paper width in mm, convert to dots (thermal printers typically 8 dots per mm)&#10;            val paperWidthMm = settings.paperWidthMm&#10;            val dotsPerMm = 8 // Standard thermal printer resolution&#10;            val paperWidthDots = paperWidthMm * dotsPerMm&#10;&#10;            // Logo should be proportional to paper width&#10;            // For receipt, logo should be small and neat: ~1/4 to 1/5 of paper width&#10;            val targetLogoSize = when {&#10;                paperWidthMm &gt;= 80 -&gt; 96  // ~12mm for 80mm paper (1/5 of width)&#10;                else -&gt; 64 // ~8mm for 58mm paper (1/5 of width)&#10;            }&#10;&#10;            Log.d(TAG, &quot;Paper width: ${paperWidthMm}mm = ${paperWidthDots} dots&quot;)&#10;            Log.d(TAG, &quot;Target logo size: ${targetLogoSize}x${targetLogoSize} dots&quot;)&#10;&#10;            // Create square bitmap from original&#10;            // Find the smaller dimension and crop from center to get square&#10;            val cropSize = min(originalBitmap.width, originalBitmap.height)&#10;            val xOffset = (originalBitmap.width - cropSize) / 2&#10;            val yOffset = (originalBitmap.height - cropSize) / 2&#10;&#10;            val squareBitmap = Bitmap.createBitmap(&#10;                originalBitmap,&#10;                xOffset,&#10;                yOffset,&#10;                cropSize,&#10;                cropSize&#10;            )&#10;&#10;            Log.d(TAG, &quot;Cropped to square: ${squareBitmap.width}x${squareBitmap.height}&quot;)&#10;&#10;            // Verify it's actually square&#10;            if (squareBitmap.width != squareBitmap.height) {&#10;                Log.e(TAG, &quot;ERROR: Bitmap is not square after cropping!&quot;)&#10;            }&#10;&#10;            // Now scale the square bitmap to target size&#10;            val scaledBitmap = squareBitmap.scale(&#10;                targetLogoSize,&#10;                targetLogoSize,&#10;                filter = true&#10;            )&#10;&#10;            Log.d(TAG, &quot;Scaled bitmap size: ${scaledBitmap.width}x${scaledBitmap.height}&quot;)&#10;&#10;            // Verify scaled is also square&#10;            if (scaledBitmap.width != scaledBitmap.height) {&#10;                Log.e(TAG, &quot;ERROR: Scaled bitmap is not square!&quot;)&#10;            }&#10;&#10;            // Print the bitmap centered&#10;            printBitmapCentered(out, scaledBitmap, paperWidthDots)&#10;&#10;            // Cleanup&#10;            squareBitmap.recycle()&#10;&#10;            // Cleanup&#10;            scaledBitmap.recycle()&#10;            originalBitmap.recycle()&#10;&#10;            Log.d(TAG, &quot;Logo printed successfully&quot;)&#10;            return true&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error printing logo&quot;, e)&#10;            return false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Print bitmap image centered using ESC/POS commands&#10;     * Uses 24-dot double-density mode for correct 1:1 aspect ratio&#10;     */&#10;    private fun printBitmapCentered(&#10;        out: OutputStream,&#10;        bitmap: Bitmap,&#10;        paperWidthDots: Int&#10;    ) {&#10;        // Convert to monochrome&#10;        val threshold = 128&#10;        val dots = Array(bitmap.height) { y -&gt;&#10;            BooleanArray(bitmap.width) { x -&gt;&#10;                val pixel = bitmap[x, y]&#10;                val r = (pixel shr 16) and 0xFF&#10;                val g = (pixel shr 8) and 0xFF&#10;                val b = pixel and 0xFF&#10;                val gray = (r + g + b) / 3&#10;                gray &lt; threshold // dark pixels become true&#10;            }&#10;        }&#10;&#10;        Log.d(TAG, &quot;Converted to monochrome: ${dots.size} rows x ${dots[0].size} cols&quot;)&#10;&#10;        // Calculate left margin for centering (in dots, then convert to mm for left margin command)&#10;        val leftMarginDots = ((paperWidthDots - bitmap.width) / 2).coerceAtLeast(0)&#10;        val leftMarginMm = (leftMarginDots / 8).coerceAtLeast(0) // 8 dots per mm&#10;&#10;        Log.d(TAG, &quot;Paper width: $paperWidthDots dots&quot;)&#10;        Log.d(TAG, &quot;Bitmap width: ${bitmap.width} dots&quot;)&#10;        Log.d(TAG, &quot;Left margin: $leftMarginDots dots (~${leftMarginMm}mm)&quot;)&#10;&#10;        // Set left margin for centering&#10;        if (leftMarginMm &gt; 0) {&#10;            // GS L nL nH - Set left margin&#10;            val nL = (leftMarginMm and 0xFF).toByte()&#10;            val nH = ((leftMarginMm shr 8) and 0xFF).toByte()&#10;            out.write(byteArrayOf(0x1D, 0x4C, nL, nH))&#10;        }&#10;&#10;        // Print using ESC * command in 24-dot double-density mode for correct aspect ratio&#10;        // Process in strips of 24 dots height (3 bytes per column)&#10;        var y = 0&#10;        while (y &lt; dots.size) {&#10;            val stripHeight = min(24, dots.size - y)&#10;&#10;            // ESC * m nL nH d1...dk&#10;            // m = 33 (24-dot double-density, 200x200 DPI) - gives 1:1 aspect ratio&#10;            val nL = (bitmap.width and 0xFF).toByte()&#10;            val nH = ((bitmap.width shr 8) and 0xFF).toByte()&#10;&#10;            out.write(byteArrayOf(0x1B, 0x2A, 33, nL, nH))&#10;&#10;            // Send bitmap data column by column&#10;            for (x in 0 until bitmap.width) {&#10;                // Each column is 3 bytes for 24 dots&#10;                val bytes = ByteArray(3)&#10;                for (k in 0 until stripHeight) {&#10;                    val dotY = y + k&#10;                    if (dotY &lt; dots.size &amp;&amp; x &lt; dots[dotY].size &amp;&amp; dots[dotY][x]) {&#10;                        val byteIndex = k / 8&#10;                        val bitIndex = 7 - (k % 8)&#10;                        bytes[byteIndex] = (bytes[byteIndex].toInt() or (1 shl bitIndex)).toByte()&#10;                    }&#10;                }&#10;                out.write(bytes)&#10;            }&#10;&#10;            // Line feed - move to next strip&#10;            out.write(byteArrayOf(0x0A))&#10;            y += 24&#10;        }&#10;&#10;        // Reset left margin to 0&#10;        out.write(byteArrayOf(0x1D, 0x4C, 0x00, 0x00))&#10;&#10;        // NO extra line feed - let ESCPosPrinter handle spacing&#10;&#10;        // Flush output to ensure all data is sent&#10;        out.flush()&#10;&#10;        // Small delay to let printer process the bitmap&#10;        try {&#10;            Thread.sleep(50)&#10;        } catch (e: InterruptedException) {&#10;            Log.w(TAG, &quot;Sleep interrupted&quot;, e)&#10;        }&#10;&#10;        Log.d(TAG, &quot;Bitmap printed, total strips: ${(bitmap.height + 23) / 24}&quot;)&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>