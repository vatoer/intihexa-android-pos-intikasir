<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/id/stargan/intikasir/feature/product/data/repository/ProductRepositoryImpl.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/id/stargan/intikasir/feature/product/data/repository/ProductRepositoryImpl.kt" />
              <option name="originalContent" value="package id.stargan.intikasir.feature.product.data.repository&#10;&#10;import id.stargan.intikasir.data.local.dao.CategoryDao&#10;import id.stargan.intikasir.data.local.dao.ProductDao&#10;import id.stargan.intikasir.domain.model.Category&#10;import id.stargan.intikasir.domain.model.Product&#10;import id.stargan.intikasir.feature.product.domain.repository.ProductRepository&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.flow&#10;import kotlinx.coroutines.flow.map&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;/**&#10; * Implementation of ProductRepository&#10; * Handles product dan category data operations&#10; */&#10;@Singleton&#10;class ProductRepositoryImpl @Inject constructor(&#10;    private val productDao: ProductDao,&#10;    private val categoryDao: CategoryDao&#10;) : ProductRepository {&#10;&#10;    override fun getAllProducts(): Flow&lt;List&lt;Product&gt;&gt; {&#10;        return productDao.getAllProducts().map { entities -&gt;&#10;            entities.map { it.toDomainModel() }&#10;        }&#10;    }&#10;&#10;    override fun getProductsByCategory(categoryId: String): Flow&lt;List&lt;Product&gt;&gt; {&#10;        return productDao.getProductsByCategory(categoryId).map { entities -&gt;&#10;            entities.map { it.toDomainModel() }&#10;        }&#10;    }&#10;&#10;    override fun getProductById(productId: String): Flow&lt;Product?&gt; {&#10;        return flow {&#10;            val entity = productDao.getProductById(productId)&#10;            emit(entity?.toDomainModel())&#10;        }&#10;    }&#10;&#10;    override fun searchProducts(query: String): Flow&lt;List&lt;Product&gt;&gt; {&#10;        return productDao.searchProducts(query).map { entities -&gt;&#10;            entities.map { it.toDomainModel() }&#10;        }&#10;    }&#10;&#10;    override suspend fun insertProduct(product: Product) {&#10;        productDao.insertProduct(product.toEntity())&#10;    }&#10;&#10;    override suspend fun updateProduct(product: Product) {&#10;        productDao.updateProduct(product.toEntity())&#10;    }&#10;&#10;    override suspend fun deleteProduct(productId: String) {&#10;        productDao.deleteProduct(productId)&#10;    }&#10;&#10;    override fun getAllCategories(): Flow&lt;List&lt;Category&gt;&gt; {&#10;        return categoryDao.getAllCategories().map { entities -&gt;&#10;            entities.map { it.toDomainModel() }&#10;        }&#10;    }&#10;&#10;    override suspend fun insertCategory(category: Category) {&#10;        categoryDao.insertCategory(category.toEntity())&#10;    }&#10;&#10;    override suspend fun updateCategory(category: Category) {&#10;        categoryDao.updateCategory(category.toEntity())&#10;    }&#10;&#10;    override suspend fun deleteCategory(categoryId: String) {&#10;        categoryDao.deleteCategory(categoryId)&#10;    }&#10;}&#10;&#10;/**&#10; * Extension function untuk convert Product domain model ke entity&#10; */&#10;private fun Product.toEntity(): id.stargan.intikasir.data.local.entity.ProductEntity {&#10;    return id.stargan.intikasir.data.local.entity.ProductEntity(&#10;        id = this.id,&#10;        name = this.name,&#10;        description = this.description,&#10;        price = this.price,&#10;        cost = this.cost,&#10;        sku = this.sku,&#10;        barcode = this.barcode,&#10;        imageUrl = this.imageUrl,&#10;        categoryId = this.categoryId,&#10;        trackStock = this.trackStock,&#10;        stock = this.stock,&#10;        lowStockThreshold = this.lowStockThreshold,&#10;        isActive = this.isActive,&#10;        createdAt = this.createdAt,&#10;        updatedAt = this.updatedAt&#10;    )&#10;}&#10;&#10;/**&#10; * Extension function untuk convert ProductEntity ke domain model&#10; */&#10;private fun id.stargan.intikasir.data.local.entity.ProductEntity.toDomainModel(): Product {&#10;    return Product(&#10;        id = this.id,&#10;        name = this.name,&#10;        description = this.description,&#10;        price = this.price,&#10;        cost = this.cost,&#10;        sku = this.sku,&#10;        barcode = this.barcode,&#10;        imageUrl = this.imageUrl,&#10;        categoryId = this.categoryId,&#10;        categoryName = this.categoryName,&#10;        trackStock = this.trackStock,&#10;        stock = this.stock,&#10;        lowStockThreshold = this.lowStockThreshold,&#10;        isActive = this.isActive,&#10;        createdAt = this.createdAt,&#10;        updatedAt = this.updatedAt&#10;    )&#10;}&#10;&#10;/**&#10; * Extension function untuk convert Category domain model ke entity&#10; */&#10;private fun Category.toEntity(): id.stargan.intikasir.data.local.entity.CategoryEntity {&#10;    return id.stargan.intikasir.data.local.entity.CategoryEntity(&#10;        id = this.id,&#10;        name = this.name,&#10;        description = this.description,&#10;        color = this.color,&#10;        icon = this.icon,&#10;        createdAt = this.createdAt,&#10;        updatedAt = this.updatedAt&#10;    )&#10;}&#10;&#10;/**&#10; * Extension function untuk convert CategoryEntity ke domain model&#10; */&#10;private fun id.stargan.intikasir.data.local.entity.CategoryEntity.toDomainModel(): Category {&#10;    return Category(&#10;        id = this.id,&#10;        name = this.name,&#10;        description = this.description,&#10;        color = this.color,&#10;        icon = this.icon,&#10;        createdAt = this.createdAt,&#10;        updatedAt = this.updatedAt&#10;    )&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package id.stargan.intikasir.feature.product.data.repository&#10;&#10;import id.stargan.intikasir.data.local.dao.CategoryDao&#10;import id.stargan.intikasir.data.local.dao.ProductDao&#10;import id.stargan.intikasir.data.local.entity.CategoryEntity&#10;import id.stargan.intikasir.data.local.entity.ProductEntity&#10;import id.stargan.intikasir.domain.model.Category&#10;import id.stargan.intikasir.domain.model.Product&#10;import id.stargan.intikasir.feature.product.domain.repository.ProductRepository&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.flow&#10;import kotlinx.coroutines.flow.map&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;/**&#10; * Implementation of ProductRepository&#10; * Handles product dan category data operations&#10; */&#10;@Singleton&#10;class ProductRepositoryImpl @Inject constructor(&#10;    private val productDao: ProductDao,&#10;    private val categoryDao: CategoryDao&#10;) : ProductRepository {&#10;&#10;    override fun getAllProducts(): Flow&lt;List&lt;Product&gt;&gt; {&#10;        return productDao.getAllProducts().map { entities -&gt;&#10;            entities.map { entity -&gt;&#10;                val categoryName = entity.categoryId?.let { categoryId -&gt;&#10;                    categoryDao.getCategoryById(categoryId)?.name&#10;                }&#10;                entity.toDomainModel(categoryName)&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun getProductsByCategory(categoryId: String): Flow&lt;List&lt;Product&gt;&gt; {&#10;        return productDao.getProductsByCategory(categoryId).map { entities -&gt;&#10;            entities.map { entity -&gt;&#10;                val categoryName = categoryDao.getCategoryById(categoryId)?.name&#10;                entity.toDomainModel(categoryName)&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun getProductById(productId: String): Flow&lt;Product?&gt; {&#10;        return flow {&#10;            val entity = productDao.getProductById(productId)&#10;            if (entity != null) {&#10;                val categoryName = entity.categoryId?.let { categoryId -&gt;&#10;                    categoryDao.getCategoryById(categoryId)?.name&#10;                }&#10;                emit(entity.toDomainModel(categoryName))&#10;            } else {&#10;                emit(null)&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun searchProducts(query: String): Flow&lt;List&lt;Product&gt;&gt; {&#10;        return productDao.searchProducts(query).map { entities -&gt;&#10;            entities.map { entity -&gt;&#10;                val categoryName = entity.categoryId?.let { categoryId -&gt;&#10;                    categoryDao.getCategoryById(categoryId)?.name&#10;                }&#10;                entity.toDomainModel(categoryName)&#10;            }&#10;        }&#10;    }&#10;&#10;    override suspend fun insertProduct(product: Product) {&#10;        productDao.insertProduct(product.toEntity())&#10;    }&#10;&#10;    override suspend fun updateProduct(product: Product) {&#10;        productDao.updateProduct(product.toEntity())&#10;    }&#10;&#10;    override suspend fun deleteProduct(productId: String) {&#10;        productDao.softDeleteProduct(productId)&#10;    }&#10;&#10;    override fun getAllCategories(): Flow&lt;List&lt;Category&gt;&gt; {&#10;        return categoryDao.getAllCategories().map { entities -&gt;&#10;            entities.map { it.toDomainModel() }&#10;        }&#10;    }&#10;&#10;    override suspend fun insertCategory(category: Category) {&#10;        categoryDao.insertCategory(category.toEntity())&#10;    }&#10;&#10;    override suspend fun updateCategory(category: Category) {&#10;        categoryDao.updateCategory(category.toEntity())&#10;    }&#10;&#10;    override suspend fun deleteCategory(categoryId: String) {&#10;        categoryDao.softDeleteCategory(categoryId)&#10;    }&#10;}&#10;&#10;/**&#10; * Extension function untuk convert Product domain model ke entity&#10; */&#10;private fun Product.toEntity(): ProductEntity {&#10;    return ProductEntity(&#10;        id = this.id,&#10;        name = this.name,&#10;        description = this.description,&#10;        price = this.price,&#10;        cost = this.cost,&#10;        sku = this.sku,&#10;        barcode = this.barcode,&#10;        imageUrl = this.imageUrl,&#10;        categoryId = this.categoryId,&#10;        trackStock = this.trackStock,&#10;        stock = this.stock,&#10;        lowStockThreshold = this.lowStockThreshold,&#10;        isActive = this.isActive,&#10;        createdAt = this.createdAt,&#10;        updatedAt = this.updatedAt&#10;    )&#10;}&#10;&#10;/**&#10; * Extension function untuk convert ProductEntity ke domain model&#10; */&#10;private fun ProductEntity.toDomainModel(categoryName: String? = null): Product {&#10;    return Product(&#10;        id = this.id,&#10;        name = this.name,&#10;        description = this.description,&#10;        price = this.price,&#10;        cost = this.cost,&#10;        sku = this.sku,&#10;        barcode = this.barcode,&#10;        imageUrl = this.imageUrl,&#10;        categoryId = this.categoryId,&#10;        categoryName = categoryName,&#10;        trackStock = this.trackStock,&#10;        stock = this.stock,&#10;        lowStockThreshold = this.lowStockThreshold,&#10;        isActive = this.isActive,&#10;        createdAt = this.createdAt,&#10;        updatedAt = this.updatedAt&#10;    )&#10;}&#10;&#10;/**&#10; * Extension function untuk convert Category domain model ke entity&#10; */&#10;private fun Category.toEntity(): CategoryEntity {&#10;    return CategoryEntity(&#10;        id = this.id,&#10;        name = this.name,&#10;        description = this.description,&#10;        color = this.color,&#10;        icon = this.icon,&#10;        createdAt = this.createdAt,&#10;        updatedAt = this.updatedAt&#10;    )&#10;}&#10;&#10;/**&#10; * Extension function untuk convert CategoryEntity ke domain model&#10; */&#10;private fun CategoryEntity.toDomainModel(): Category {&#10;    return Category(&#10;        id = this.id,&#10;        name = this.name,&#10;        description = this.description,&#10;        color = this.color,&#10;        icon = this.icon,&#10;        createdAt = this.createdAt,&#10;        updatedAt = this.updatedAt&#10;    )&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>