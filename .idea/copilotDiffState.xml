<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/id/stargan/intikasir/feature/pos/data/TransactionRepositoryImpl.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/id/stargan/intikasir/feature/pos/data/TransactionRepositoryImpl.kt" />
              <option name="originalContent" value="package id.stargan.intikasir.feature.pos.data&#10;&#10;import id.stargan.intikasir.feature.pos.domain.TransactionRepository&#10;import id.stargan.intikasir.data.local.dao.TransactionDao&#10;import id.stargan.intikasir.data.local.dao.TransactionItemDao&#10;import id.stargan.intikasir.data.local.dao.ProductDao&#10;import id.stargan.intikasir.data.local.entity.TransactionEntity&#10;import id.stargan.intikasir.data.local.entity.TransactionItemEntity&#10;import id.stargan.intikasir.data.local.entity.PaymentMethod&#10;import id.stargan.intikasir.data.local.entity.TransactionStatus&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import java.text.SimpleDateFormat&#10;import java.util.Date&#10;import java.util.Locale&#10;import javax.inject.Inject&#10;&#10;class TransactionRepositoryImpl @Inject constructor(&#10;    private val transactionDao: TransactionDao,&#10;    private val transactionItemDao: TransactionItemDao,&#10;    private val productDao: ProductDao&#10;) : TransactionRepository {&#10;&#10;    override suspend fun createTransaction(&#10;        cashierId: String,&#10;        cashierName: String,&#10;        items: List&lt;Pair&lt;String, Int&gt;&gt;,&#10;        paymentMethod: PaymentMethod,&#10;        subtotal: Double,&#10;        tax: Double,&#10;        discount: Double,&#10;        total: Double,&#10;        cashReceived: Double,&#10;        cashChange: Double,&#10;        notes: String?,&#10;        status: TransactionStatus&#10;    ): String = withContext(Dispatchers.IO) {&#10;        // Generate transaction number (INV-YYYYMMDD-####)&#10;        val dateFormat = SimpleDateFormat(&quot;yyyyMMdd&quot;, Locale.getDefault())&#10;        val datePart = dateFormat.format(Date())&#10;        val prefix = &quot;INV-$datePart&quot;&#10;        val lastNumber = transactionDao.getLastTransactionNumber(prefix) // e.g. INV-20231115-0007&#10;        val nextSeq = (lastNumber?.substringAfterLast('-')?.toIntOrNull() ?: 0) + 1&#10;        val transactionNumber = &quot;$prefix-${String.format(Locale.getDefault(), &quot;%04d&quot;, nextSeq)}&quot;&#10;&#10;        val transaction = TransactionEntity(&#10;            transactionNumber = transactionNumber,&#10;            cashierId = cashierId,&#10;            cashierName = cashierName,&#10;            paymentMethod = paymentMethod,&#10;            subtotal = subtotal,&#10;            tax = tax,&#10;            discount = discount,&#10;            total = total,&#10;            cashReceived = cashReceived,&#10;            cashChange = cashChange,&#10;            notes = notes,&#10;            status = status&#10;        )&#10;        transactionDao.insertTransaction(transaction)&#10;&#10;        // Insert items and update product stock&#10;        val productMap = productDao.getProductsByIds(items.map { it.first }).associateBy { it.id }&#10;        val itemEntities = items.map { (productId, qty) -&gt;&#10;            val p = productMap[productId] ?: throw IllegalArgumentException(&quot;Product not found: $productId&quot;)&#10;            TransactionItemEntity(&#10;                transactionId = transaction.id,&#10;                productId = productId,&#10;                productName = p.name,&#10;                productPrice = p.price,&#10;                productSku = p.sku,&#10;                quantity = qty,&#10;                unitPrice = p.price,&#10;                discount = 0.0,&#10;                subtotal = (p.price * qty) - 0.0&#10;            )&#10;        }&#10;        transactionItemDao.insertItems(itemEntities)&#10;&#10;        // Update stock (decrement)&#10;        items.forEach { (productId, qty) -&gt;&#10;            productDao.decrementStock(productId, qty)&#10;        }&#10;&#10;        transaction.id&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package id.stargan.intikasir.feature.pos.data&#10;&#10;import id.stargan.intikasir.feature.pos.domain.TransactionRepository&#10;import id.stargan.intikasir.data.local.dao.TransactionDao&#10;import id.stargan.intikasir.data.local.dao.TransactionItemDao&#10;import id.stargan.intikasir.data.local.dao.ProductDao&#10;import id.stargan.intikasir.data.local.entity.TransactionEntity&#10;import id.stargan.intikasir.data.local.entity.TransactionItemEntity&#10;import id.stargan.intikasir.data.local.entity.PaymentMethod&#10;import id.stargan.intikasir.data.local.entity.TransactionStatus&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import java.text.SimpleDateFormat&#10;import java.util.Date&#10;import java.util.Locale&#10;import javax.inject.Inject&#10;&#10;class TransactionRepositoryImpl @Inject constructor(&#10;    private val transactionDao: TransactionDao,&#10;    private val transactionItemDao: TransactionItemDao,&#10;    private val productDao: ProductDao&#10;) : TransactionRepository {&#10;&#10;    override suspend fun createTransaction(&#10;        cashierId: String,&#10;        cashierName: String,&#10;        items: List&lt;Pair&lt;String, Int&gt;&gt;,&#10;        paymentMethod: PaymentMethod,&#10;        subtotal: Double,&#10;        tax: Double,&#10;        discount: Double,&#10;        total: Double,&#10;        cashReceived: Double,&#10;        cashChange: Double,&#10;        notes: String?,&#10;        status: TransactionStatus&#10;    ): String = withContext(Dispatchers.IO) {&#10;        // Generate transaction number (INV-YYYYMMDD-####)&#10;        val dateFormat = SimpleDateFormat(&quot;yyyyMMdd&quot;, Locale.getDefault())&#10;        val datePart = dateFormat.format(Date())&#10;        val prefix = &quot;INV-$datePart&quot;&#10;        val lastNumber = transactionDao.getLastTransactionNumber(prefix) // e.g. INV-20231115-0007&#10;        val nextSeq = (lastNumber?.substringAfterLast('-')?.toIntOrNull() ?: 0) + 1&#10;        val transactionNumber = &quot;$prefix-${String.format(Locale.getDefault(), &quot;%04d&quot;, nextSeq)}&quot;&#10;&#10;        val transaction = TransactionEntity(&#10;            transactionNumber = transactionNumber,&#10;            cashierId = cashierId,&#10;            cashierName = cashierName,&#10;            paymentMethod = paymentMethod,&#10;            subtotal = subtotal,&#10;            tax = tax,&#10;            discount = discount,&#10;            total = total,&#10;            cashReceived = cashReceived,&#10;            cashChange = cashChange,&#10;            notes = notes,&#10;            status = status&#10;        )&#10;        transactionDao.insertTransaction(transaction)&#10;&#10;        // Insert items and update product stock&#10;        val productMap = productDao.getProductsByIds(items.map { it.first }).associateBy { it.id }&#10;        val itemEntities = items.map { (productId, qty) -&gt;&#10;            val p = productMap[productId] ?: throw IllegalArgumentException(&quot;Product not found: $productId&quot;)&#10;            val itemDiscount = 0.0 // future: pass in per-item discount&#10;            TransactionItemEntity(&#10;                transactionId = transaction.id,&#10;                productId = productId,&#10;                productName = p.name,&#10;                productPrice = p.price,&#10;                productSku = p.sku,&#10;                quantity = qty,&#10;                unitPrice = p.price,&#10;                discount = itemDiscount,&#10;                subtotal = (p.price * qty) - itemDiscount&#10;            )&#10;        }&#10;        transactionItemDao.insertItems(itemEntities)&#10;&#10;        // Update stock (decrement)&#10;        items.forEach { (productId, qty) -&gt;&#10;            productDao.decrementStock(productId, qty)&#10;        }&#10;&#10;        transaction.id&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/id/stargan/intikasir/feature/pos/domain/TransactionRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/id/stargan/intikasir/feature/pos/domain/TransactionRepository.kt" />
              <option name="originalContent" value="package id.stargan.intikasir.feature.pos.domain&#10;}&#10;    ): String&#10;        status: TransactionStatus&#10;        notes: String?,&#10;        cashChange: Double,&#10;        cashReceived: Double,&#10;        total: Double,&#10;        discount: Double,&#10;        tax: Double,&#10;        subtotal: Double,&#10;        paymentMethod: PaymentMethod,&#10;        items: List&lt;Pair&lt;String, Int&gt;&gt;, // productId to quantity&#10;        cashierName: String,&#10;        cashierId: String,&#10;    suspend fun createTransaction(&#10;interface TransactionRepository {&#10;&#10;import id.stargan.intikasir.data.local.entity.TransactionStatus&#10;import id.stargan.intikasir.data.local.entity.PaymentMethod&#10;&#10;&#10;" />
              <option name="updatedContent" value="package id.stargan.intikasir.feature.pos.domain&#10;&#10;import id.stargan.intikasir.data.local.entity.PaymentMethod&#10;import id.stargan.intikasir.data.local.entity.TransactionStatus&#10;&#10;interface TransactionRepository {&#10;    suspend fun createTransaction(&#10;        cashierId: String,&#10;        cashierName: String,&#10;        items: List&lt;Pair&lt;String, Int&gt;&gt;, // productId to quantity&#10;        paymentMethod: PaymentMethod,&#10;        subtotal: Double,&#10;        tax: Double,&#10;        discount: Double,&#10;        total: Double,&#10;        cashReceived: Double,&#10;        cashChange: Double,&#10;        notes: String?,&#10;        status: TransactionStatus&#10;    ): String&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/id/stargan/intikasir/feature/pos/domain/model/CartItem.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/id/stargan/intikasir/feature/pos/domain/model/CartItem.kt" />
              <option name="originalContent" value="package id.stargan.intikasir.feature.pos.domain.model&#10;&#10;import id.stargan.intikasir.domain.model.Product&#10;&#10;/** Cart item representing a product selected for purchase */&#10;data class CartItem(&#10;    val productId: String,&#10;    val name: String,&#10;    val price: Double,&#10;    val quantity: Int,&#10;    val imageUrl: String?,&#10;    val stock: Int,&#10;    val isActive: Boolean&#10;) {&#10;    val subtotal: Double get() = price * quantity&#10;}&#10;&#10;fun Product.toCartItem(quantity: Int = 1): CartItem = CartItem(&#10;    productId = id,&#10;    name = name,&#10;    price = price,&#10;    quantity = quantity,&#10;    imageUrl = imageUrl,&#10;    stock = stock,&#10;    isActive = isActive&#10;)&#10;" />
              <option name="updatedContent" value="package id.stargan.intikasir.feature.pos.domain.model&#10;&#10;import id.stargan.intikasir.domain.model.Product&#10;&#10;/** Cart item representing a product selected for purchase */&#10;data class CartItem(&#10;    val productId: String,&#10;    val name: String,&#10;    val price: Double,&#10;    val quantity: Int,&#10;    val imageUrl: String?,&#10;    val stock: Int,&#10;    val isActive: Boolean,&#10;    val itemDiscount: Double = 0.0&#10;) {&#10;    val subtotal: Double get() = (price * quantity) - itemDiscount.coerceAtMost(price * quantity)&#10;}&#10;&#10;fun Product.toCartItem(quantity: Int = 1, itemDiscount: Double = 0.0): CartItem = CartItem(&#10;    productId = id,&#10;    name = name,&#10;    price = price,&#10;    quantity = quantity,&#10;    imageUrl = imageUrl,&#10;    stock = stock,&#10;    isActive = isActive,&#10;    itemDiscount = itemDiscount&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/id/stargan/intikasir/feature/pos/ui/PosScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/id/stargan/intikasir/feature/pos/ui/PosScreen.kt" />
              <option name="originalContent" value="package id.stargan.intikasir.feature.pos.ui&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Search&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.input.TextFieldValue&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import id.stargan.intikasir.feature.pos.ui.components.CartSummary&#10;import id.stargan.intikasir.feature.pos.ui.components.PayButton&#10;import id.stargan.intikasir.feature.pos.ui.components.PosProductItem&#10;&#10;/**&#10; * POS Screen (Portrait) with three vertical zones:&#10; * Top: Cart Summary (non-scroll)&#10; * Middle: Scrollable product list&#10; * Bottom: Floating Pay Button&#10; */&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun PosScreen(&#10;    onPay: (Double) -&gt; Unit,&#10;    modifier: Modifier = Modifier,&#10;    viewModel: PosViewModel = hiltViewModel()&#10;) {&#10;    val state by viewModel.uiState.collectAsState()&#10;    val searchState = remember { mutableStateOf(TextFieldValue(&quot;&quot;)) }&#10;&#10;    Scaffold(&#10;        floatingActionButton = {&#10;            PayButton(state = state, onPay = { onPay(state.total) })&#10;        },&#10;        floatingActionButtonPosition = FabPosition.Center,&#10;        modifier = modifier&#10;    ) { padding -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(padding)&#10;        ) {&#10;            // Top: Cart Summary&#10;            CartSummary(state = state, onClear = { viewModel.clearCart() })&#10;&#10;            // Middle: Search + Product List (scrollable)&#10;            TextField(&#10;                value = searchState.value,&#10;                onValueChange = {&#10;                    searchState.value = it&#10;                    viewModel.onSearchChange(it.text)&#10;                },&#10;                leadingIcon = { Icon(Icons.Default.Search, contentDescription = null) },&#10;                placeholder = { Text(&quot;Cari produk...&quot;) },&#10;                singleLine = true,&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp)&#10;            )&#10;            Divider()&#10;            Box(modifier = Modifier.weight(1f)) {&#10;                if (state.isLoading) {&#10;                    CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))&#10;                } else {&#10;                    val filtered = state.products.filter { p -&gt;&#10;                        val q = state.searchQuery.trim().lowercase()&#10;                        if (q.isEmpty()) true else p.name.lowercase().contains(q) || (p.barcode?.lowercase()?.contains(q) == true)&#10;                    }&#10;                    LazyColumn(&#10;                        contentPadding = PaddingValues(bottom = 96.dp, start = 16.dp, end = 16.dp, top = 16.dp),&#10;                        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                    ) {&#10;                        items(filtered, key = { it.id }) { product -&gt;&#10;                            val item = state.cart[product.id]&#10;                            PosProductItem(&#10;                                product = product,&#10;                                cartItem = item,&#10;                                onAdd = { viewModel.addOrIncrement(product.id) },&#10;                                onChangeQty = { qty -&gt; viewModel.setQuantity(product.id, qty) }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;&#10;" />
              <option name="updatedContent" value="package id.stargan.intikasir.feature.pos.ui&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Search&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.input.TextFieldValue&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import id.stargan.intikasir.data.local.entity.PaymentMethod&#10;import id.stargan.intikasir.feature.pos.ui.components.CartSummary&#10;import id.stargan.intikasir.feature.pos.ui.components.PayButton&#10;import id.stargan.intikasir.feature.pos.ui.components.PosProductItem&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * POS Screen (Portrait) with three vertical zones:&#10; * Top: Cart Summary (non-scroll)&#10; * Middle: Scrollable product list&#10; * Bottom: Floating Pay Button&#10; */&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun PosScreen(&#10;    onPay: (Double) -&gt; Unit,&#10;    modifier: Modifier = Modifier,&#10;    viewModel: PosViewModel = hiltViewModel()&#10;) {&#10;    val state by viewModel.uiState.collectAsState()&#10;    val searchState = remember { mutableStateOf(TextFieldValue(&quot;&quot;)) }&#10;    var showPaymentDialog by remember { mutableStateOf(false) }&#10;    var cashText by remember(showPaymentDialog) { mutableStateOf(state.total.toInt().toString()) }&#10;    val scope = rememberCoroutineScope()&#10;&#10;    Scaffold(&#10;        floatingActionButton = {&#10;            PayButton(state = state, onPay = { showPaymentDialog = true })&#10;        },&#10;        floatingActionButtonPosition = FabPosition.Center,&#10;        modifier = modifier&#10;    ) { padding -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(padding)&#10;        ) {&#10;            // Top: Cart Summary&#10;            CartSummary(state = state, onClear = { viewModel.clearCart() })&#10;&#10;            // Global Discount &amp; Tax Row&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 16.dp, vertical = 8.dp),&#10;                horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                OutlinedTextField(&#10;                    value = state.discountGlobal.takeIf { it &gt; 0 }?.toInt()?.toString() ?: &quot;&quot;,&#10;                    onValueChange = { txt -&gt;&#10;                        val v = txt.filter { it.isDigit() }.toDoubleOrNull() ?: 0.0&#10;                        viewModel.setGlobalDiscount(v)&#10;                    },&#10;                    label = { Text(&quot;Diskon&quot;) },&#10;                    prefix = { Text(&quot;Rp &quot;) },&#10;                    singleLine = true,&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;                OutlinedTextField(&#10;                    value = (state.taxRate * 100).takeIf { it &gt; 0 }?.toInt()?.toString() ?: &quot;&quot;,&#10;                    onValueChange = { txt -&gt;&#10;                        val v = txt.filter { it.isDigit() }.toDoubleOrNull() ?: 0.0&#10;                        viewModel.setTaxRate(v)&#10;                    },&#10;                    label = { Text(&quot;PPN %&quot;) },&#10;                    singleLine = true,&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;                // Payment method selector (simple)&#10;                var expanded by remember { mutableStateOf(false) }&#10;                ExposedDropdownMenuBox(expanded = expanded, onExpandedChange = { expanded = it }) {&#10;                    OutlinedTextField(&#10;                        value = state.paymentMethod.name,&#10;                        onValueChange = {},&#10;                        readOnly = true,&#10;                        label = { Text(&quot;Metode&quot;) },&#10;                        trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded) },&#10;                        modifier = Modifier.menuAnchor().weight(1f)&#10;                    )&#10;                    ExposedDropdownMenu(expanded = expanded, onDismissRequest = { expanded = false }) {&#10;                        PaymentMethod.values().forEach { method -&gt;&#10;                            DropdownMenuItem(text = { Text(method.name) }, onClick = {&#10;                                viewModel.setPaymentMethod(method)&#10;                                expanded = false&#10;                            })&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Middle: Search + Product List (scrollable)&#10;            TextField(&#10;                value = searchState.value,&#10;                onValueChange = {&#10;                    searchState.value = it&#10;                    viewModel.onSearchChange(it.text)&#10;                },&#10;                leadingIcon = { Icon(Icons.Default.Search, contentDescription = null) },&#10;                placeholder = { Text(&quot;Cari produk...&quot;) },&#10;                singleLine = true,&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp)&#10;            )&#10;            Divider()&#10;            Box(modifier = Modifier.weight(1f)) {&#10;                if (state.isLoading) {&#10;                    CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))&#10;                } else {&#10;                    val filtered = state.products.filter { p -&gt;&#10;                        val q = state.searchQuery.trim().lowercase()&#10;                        if (q.isEmpty()) true else p.name.lowercase().contains(q) || (p.barcode?.lowercase()?.contains(q) == true)&#10;                    }&#10;                    LazyColumn(&#10;                        contentPadding = PaddingValues(bottom = 96.dp, start = 16.dp, end = 16.dp, top = 16.dp),&#10;                        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                    ) {&#10;                        items(filtered, key = { it.id }) { product -&gt;&#10;                            val item = state.cart[product.id]&#10;                            PosProductItem(&#10;                                product = product,&#10;                                cartItem = item,&#10;                                onAdd = { viewModel.addOrIncrement(product.id) },&#10;                                onChangeQty = { qty -&gt; viewModel.setQuantity(product.id, qty) }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    if (showPaymentDialog) {&#10;        AlertDialog(&#10;            onDismissRequest = { showPaymentDialog = false },&#10;            confirmButton = {&#10;                TextButton(onClick = {&#10;                    scope.launch {&#10;                        val received = if (state.paymentMethod == PaymentMethod.CASH) (cashText.toDoubleOrNull() ?: state.total) else null&#10;                        viewModel.finalizeTransaction(cashierId = &quot;cashier-1&quot;, cashierName = &quot;Kasir&quot;, cashReceived = received)&#10;                        showPaymentDialog = false&#10;                        onPay(state.total)&#10;                    }&#10;                }) { Text(&quot;Konfirmasi&quot;) }&#10;            },&#10;            dismissButton = { TextButton(onClick = { showPaymentDialog = false }) { Text(&quot;Batal&quot;) } },&#10;            title = { Text(&quot;Konfirmasi Pembayaran&quot;) },&#10;            text = {&#10;                Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {&#10;                    Text(&quot;Total: Rp ${state.total.toInt()}&quot;)&#10;                    if (state.paymentMethod == PaymentMethod.CASH) {&#10;                        OutlinedTextField(&#10;                            value = cashText,&#10;                            onValueChange = { cashText = it.filter { c -&gt; c.isDigit() } },&#10;                            label = { Text(&quot;Tunai Diterima&quot;) },&#10;                            prefix = { Text(&quot;Rp &quot;) },&#10;                            singleLine = true&#10;                        )&#10;                        val received = cashText.toDoubleOrNull() ?: state.total&#10;                        val change = (received - state.total).coerceAtLeast(0.0)&#10;                        Text(&quot;Kembali: Rp ${change.toInt()}&quot;)&#10;                    }&#10;                    if (state.discountGlobal &gt; 0) Text(&quot;Diskon: Rp ${state.discountGlobal.toInt()}&quot;)&#10;                    if (state.taxRate &gt; 0) Text(&quot;PPN: ${(state.taxRate * 100).toInt()}%&quot;)&#10;                }&#10;            }&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/id/stargan/intikasir/feature/pos/ui/PosViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/id/stargan/intikasir/feature/pos/ui/PosViewModel.kt" />
              <option name="originalContent" value="package id.stargan.intikasir.feature.pos.ui&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import id.stargan.intikasir.feature.product.domain.usecase.GetAllProductsUseCase&#10;import id.stargan.intikasir.feature.pos.domain.model.CartItem&#10;import id.stargan.intikasir.feature.pos.domain.model.toCartItem&#10;import id.stargan.intikasir.data.local.entity.PaymentMethod&#10;import id.stargan.intikasir.data.local.entity.TransactionStatus&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;import id.stargan.intikasir.feature.pos.domain.TransactionRepository&#10;&#10;@HiltViewModel&#10;class PosViewModel @Inject constructor(&#10;    private val getAllProductsUseCase: GetAllProductsUseCase&#10;) : ViewModel() {&#10;&#10;    data class UiState(&#10;        val products: List&lt;id.stargan.intikasir.domain.model.Product&gt; = emptyList(),&#10;        val cart: Map&lt;String, CartItem&gt; = emptyMap(),&#10;        val searchQuery: String = &quot;&quot;,&#10;        val categoryId: String? = null,&#10;        val isLoading: Boolean = false,&#10;        val error: String? = null,&#10;        val taxRate: Double = 0.0,&#10;        val discountGlobal: Double = 0.0,&#10;        val paymentMethod: PaymentMethod = PaymentMethod.CASH,&#10;        val isSaving: Boolean = false,&#10;        val lastSavedTransactionId: String? = null&#10;    ) {&#10;        val cartItems: List&lt;CartItem&gt; get() = cart.values.toList()&#10;        val totalQuantity: Int get() = cartItems.sumOf { it.quantity }&#10;        val subtotal: Double get() = cartItems.sumOf { it.subtotal }&#10;        val tax: Double get() = subtotal * taxRate&#10;        val total: Double get() = subtotal + tax - discountGlobal&#10;&#10;        override fun toString(): String = &quot;cartItems=${cart.size} subtotal=$subtotal discountGlobal=$discountGlobal taxRate=$taxRate total=$total&quot;&#10;    }&#10;&#10;    private val _uiState = MutableStateFlow(UiState())&#10;    val uiState: StateFlow&lt;UiState&gt; = _uiState&#10;&#10;    // Placeholder repository (will be injected later)&#10;    @Inject lateinit var transactionRepository: TransactionRepository&#10;&#10;    init { loadProducts() }&#10;&#10;    private fun loadProducts() {&#10;        viewModelScope.launch {&#10;            _uiState.update { it.copy(isLoading = true) }&#10;            try {&#10;                getAllProductsUseCase().collect { list -&gt;&#10;                    _uiState.update { current -&gt;&#10;                        current.copy(&#10;                            products = list.filter { it.isActive },&#10;                            isLoading = false,&#10;                            error = null&#10;                        )&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.update { it.copy(isLoading = false, error = e.message) }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun onSearchChange(query: String) {&#10;        _uiState.update { it.copy(searchQuery = query) }&#10;    }&#10;&#10;    fun addOrIncrement(productId: String) {&#10;        val product = _uiState.value.products.find { it.id == productId } ?: return&#10;        _uiState.update { state -&gt;&#10;            val existing = state.cart[productId]&#10;            val nextQty = (existing?.quantity ?: 0) + 1&#10;            if (nextQty &gt; product.stock) return@update state // exceed stock&#10;            state.copy(cart = state.cart + (productId to product.toCartItem(nextQty)))&#10;        }&#10;    }&#10;&#10;    fun setQuantity(productId: String, quantity: Int) {&#10;        if (quantity &lt; 0) { // delete sentinel&#10;            remove(productId); return&#10;        }&#10;        val product = _uiState.value.products.find { it.id == productId } ?: return&#10;        if (quantity &gt; product.stock) return&#10;        _uiState.update { state -&gt;&#10;            if (quantity == 0) state.copy(cart = state.cart - productId)&#10;            else state.copy(cart = state.cart + (productId to product.toCartItem(quantity)))&#10;        }&#10;    }&#10;&#10;    fun decrement(productId: String) {&#10;        val existing = _uiState.value.cart[productId] ?: return&#10;        val newQty = existing.quantity - 1&#10;        setQuantity(productId, newQty)&#10;    }&#10;&#10;    fun remove(productId: String) {&#10;        _uiState.update { it.copy(cart = it.cart - productId) }&#10;    }&#10;&#10;    fun clearCart() {&#10;        _uiState.update { it.copy(cart = emptyMap()) }&#10;    }&#10;&#10;    fun setGlobalDiscount(amount: Double) {&#10;        _uiState.update { it.copy(discountGlobal = amount.coerceAtLeast(0.0)) }&#10;    }&#10;&#10;    fun setTaxRate(ratePercent: Double) {&#10;        val rate = (ratePercent / 100.0).coerceIn(0.0, 0.25) // limit max 25%&#10;        _uiState.update { it.copy(taxRate = rate) }&#10;    }&#10;&#10;    fun setPaymentMethod(method: PaymentMethod) {&#10;        _uiState.update { it.copy(paymentMethod = method) }&#10;    }&#10;&#10;    suspend fun finalizeTransaction(cashierId: String, cashierName: String, cashReceived: Double? = null, notes: String? = null) {&#10;        val state = _uiState.value&#10;        if (state.cartItems.isEmpty()) return&#10;        _uiState.update { it.copy(isSaving = true) }&#10;        try {&#10;            val subtotal = state.subtotal&#10;            val discount = state.discountGlobal.coerceAtMost(subtotal)&#10;            val taxableBase = subtotal - discount&#10;            val tax = taxableBase * state.taxRate&#10;            val total = taxableBase + tax&#10;            val received = if (state.paymentMethod == PaymentMethod.CASH) (cashReceived ?: total) else total&#10;            val change = if (state.paymentMethod == PaymentMethod.CASH) (received - total).coerceAtLeast(0.0) else 0.0&#10;&#10;            val transactionId = transactionRepository.createTransaction(&#10;                cashierId = cashierId,&#10;                cashierName = cashierName,&#10;                items = state.cartItems.map { it.productId to it.quantity },&#10;                paymentMethod = state.paymentMethod,&#10;                subtotal = subtotal,&#10;                tax = tax,&#10;                discount = discount,&#10;                total = total,&#10;                cashReceived = received,&#10;                cashChange = change,&#10;                notes = notes,&#10;                status = TransactionStatus.COMPLETED&#10;            )&#10;            // Clear cart after success&#10;            _uiState.update { it.copy(cart = emptyMap(), isSaving = false, lastSavedTransactionId = transactionId) }&#10;        } catch (e: Exception) {&#10;            _uiState.update { it.copy(isSaving = false, error = e.message) }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package id.stargan.intikasir.feature.pos.ui&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import id.stargan.intikasir.feature.product.domain.usecase.GetAllProductsUseCase&#10;import id.stargan.intikasir.feature.pos.domain.model.CartItem&#10;import id.stargan.intikasir.feature.pos.domain.model.toCartItem&#10;import id.stargan.intikasir.data.local.entity.PaymentMethod&#10;import id.stargan.intikasir.data.local.entity.TransactionStatus&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;import id.stargan.intikasir.feature.pos.domain.TransactionRepository&#10;&#10;@HiltViewModel&#10;class PosViewModel @Inject constructor(&#10;    private val getAllProductsUseCase: GetAllProductsUseCase,&#10;    private val transactionRepository: TransactionRepository&#10;) : ViewModel() {&#10;&#10;    data class UiState(&#10;        val products: List&lt;id.stargan.intikasir.domain.model.Product&gt; = emptyList(),&#10;        val cart: Map&lt;String, CartItem&gt; = emptyMap(),&#10;        val searchQuery: String = &quot;&quot;,&#10;        val categoryId: String? = null,&#10;        val isLoading: Boolean = false,&#10;        val error: String? = null,&#10;        val taxRate: Double = 0.0,&#10;        val discountGlobal: Double = 0.0,&#10;        val paymentMethod: PaymentMethod = PaymentMethod.CASH,&#10;        val isSaving: Boolean = false,&#10;        val lastSavedTransactionId: String? = null&#10;    ) {&#10;        val cartItems: List&lt;CartItem&gt; get() = cart.values.toList()&#10;        val totalQuantity: Int get() = cartItems.sumOf { it.quantity }&#10;        val subtotal: Double get() = cartItems.sumOf { it.subtotal }&#10;        val tax: Double get() = subtotal * taxRate&#10;        val total: Double get() = subtotal + tax - discountGlobal&#10;&#10;        override fun toString(): String = &quot;cartItems=${cart.size} subtotal=$subtotal discountGlobal=$discountGlobal taxRate=$taxRate total=$total&quot;&#10;    }&#10;&#10;    private val _uiState = MutableStateFlow(UiState())&#10;    val uiState: StateFlow&lt;UiState&gt; = _uiState&#10;&#10;    init { loadProducts() }&#10;&#10;    private fun loadProducts() {&#10;        viewModelScope.launch {&#10;            _uiState.update { it.copy(isLoading = true) }&#10;            try {&#10;                getAllProductsUseCase().collect { list -&gt;&#10;                    _uiState.update { current -&gt;&#10;                        current.copy(&#10;                            products = list.filter { it.isActive },&#10;                            isLoading = false,&#10;                            error = null&#10;                        )&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.update { it.copy(isLoading = false, error = e.message) }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun onSearchChange(query: String) {&#10;        _uiState.update { it.copy(searchQuery = query) }&#10;    }&#10;&#10;    fun addOrIncrement(productId: String) {&#10;        val product = _uiState.value.products.find { it.id == productId } ?: return&#10;        _uiState.update { state -&gt;&#10;            val existing = state.cart[productId]&#10;            val nextQty = (existing?.quantity ?: 0) + 1&#10;            if (nextQty &gt; product.stock) return@update state // exceed stock&#10;            state.copy(cart = state.cart + (productId to product.toCartItem(nextQty)))&#10;        }&#10;    }&#10;&#10;    fun setQuantity(productId: String, quantity: Int) {&#10;        if (quantity &lt; 0) { // delete sentinel&#10;            remove(productId); return&#10;        }&#10;        val product = _uiState.value.products.find { it.id == productId } ?: return&#10;        if (quantity &gt; product.stock) return&#10;        _uiState.update { state -&gt;&#10;            if (quantity == 0) state.copy(cart = state.cart - productId)&#10;            else state.copy(cart = state.cart + (productId to product.toCartItem(quantity)))&#10;        }&#10;    }&#10;&#10;    fun decrement(productId: String) {&#10;        val existing = _uiState.value.cart[productId] ?: return&#10;        val newQty = existing.quantity - 1&#10;        setQuantity(productId, newQty)&#10;    }&#10;&#10;    fun remove(productId: String) {&#10;        _uiState.update { it.copy(cart = it.cart - productId) }&#10;    }&#10;&#10;    fun clearCart() {&#10;        _uiState.update { it.copy(cart = emptyMap()) }&#10;    }&#10;&#10;    fun setGlobalDiscount(amount: Double) {&#10;        _uiState.update { it.copy(discountGlobal = amount.coerceAtLeast(0.0)) }&#10;    }&#10;&#10;    fun setTaxRate(ratePercent: Double) {&#10;        val rate = (ratePercent / 100.0).coerceIn(0.0, 0.25) // limit max 25%&#10;        _uiState.update { it.copy(taxRate = rate) }&#10;    }&#10;&#10;    fun setPaymentMethod(method: PaymentMethod) {&#10;        _uiState.update { it.copy(paymentMethod = method) }&#10;    }&#10;&#10;    suspend fun finalizeTransaction(cashierId: String, cashierName: String, cashReceived: Double? = null, notes: String? = null) {&#10;        val state = _uiState.value&#10;        if (state.cartItems.isEmpty()) return&#10;        _uiState.update { it.copy(isSaving = true) }&#10;        try {&#10;            val subtotal = state.subtotal&#10;            val discount = state.discountGlobal.coerceAtMost(subtotal)&#10;            val taxableBase = subtotal - discount&#10;            val tax = taxableBase * state.taxRate&#10;            val total = taxableBase + tax&#10;            val received = if (state.paymentMethod == PaymentMethod.CASH) (cashReceived ?: total) else total&#10;            val change = if (state.paymentMethod == PaymentMethod.CASH) (received - total).coerceAtLeast(0.0) else 0.0&#10;&#10;            val transactionId = transactionRepository.createTransaction(&#10;                cashierId = cashierId,&#10;                cashierName = cashierName,&#10;                items = state.cartItems.map { it.productId to it.quantity },&#10;                paymentMethod = state.paymentMethod,&#10;                subtotal = subtotal,&#10;                tax = tax,&#10;                discount = discount,&#10;                total = total,&#10;                cashReceived = received,&#10;                cashChange = change,&#10;                notes = notes,&#10;                status = TransactionStatus.COMPLETED&#10;            )&#10;            // Clear cart after success&#10;            _uiState.update { it.copy(cart = emptyMap(), isSaving = false, lastSavedTransactionId = transactionId) }&#10;        } catch (e: Exception) {&#10;            _uiState.update { it.copy(isSaving = false, error = e.message) }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>